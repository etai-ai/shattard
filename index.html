<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>SHATTARD: AWAKEN</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --matrix-green: #00ff41;
    --matrix-dark: #003b00;
    --matrix-dim: #0a3a0a;
    --matrix-bright: #7dff7d;
    --matrix-bg: #000a00;
    --glow: 0 0 10px #00ff41, 0 0 20px #00ff4180, 0 0 40px #00ff4140;
    --glow-sm: 0 0 5px #00ff41, 0 0 10px #00ff4180;
  }

  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #000;
    font-family: 'Share Tech Mono', monospace;
    color: var(--matrix-green);
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }

  canvas#rain {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    opacity: 0.35;
  }

  /* SCREENS */
  .screen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: opacity 0.8s;
    background: radial-gradient(ellipse at center, #001a00 0%, #000 70%);
  }
  .screen.hidden { opacity: 0; pointer-events: none; }

  /* TITLE SCREEN */
  #titleScreen h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(2rem, 8vw, 4rem);
    font-weight: 900;
    letter-spacing: 0.15em;
    text-shadow: var(--glow);
    animation: titlePulse 3s ease-in-out infinite;
    text-align: center;
  }
  #titleScreen .subtitle {
    font-size: clamp(0.7rem, 2.5vw, 1rem);
    color: var(--matrix-bright);
    opacity: 0.6;
    margin-top: 0.5rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
  }
  @keyframes titlePulse {
    0%, 100% { text-shadow: var(--glow); opacity: 1; }
    50% { text-shadow: 0 0 20px #00ff41, 0 0 40px #00ff41, 0 0 80px #00ff41; opacity: 0.85; }
  }

  .start-btn {
    margin-top: 3rem;
    padding: 1rem 3rem;
    background: transparent;
    border: 1px solid var(--matrix-green);
    color: var(--matrix-green);
    font-family: 'Share Tech Mono', monospace;
    font-size: 1.1rem;
    letter-spacing: 0.2em;
    cursor: pointer;
    text-transform: uppercase;
    position: relative;
    overflow: hidden;
    animation: btnFlicker 4s infinite;
  }
  .start-btn::before {
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, #00ff4120, transparent);
    transition: left 0.5s;
  }
  .start-btn:active::before { left: 100%; }
  .start-btn:active {
    background: #00ff4120;
    box-shadow: var(--glow);
  }
  @keyframes btnFlicker {
    0%, 95%, 100% { opacity: 1; }
    96% { opacity: 0.4; }
    97% { opacity: 1; }
    98% { opacity: 0.6; }
  }

  .instructions {
    margin-top: 2rem;
    font-size: clamp(0.6rem, 2vw, 0.8rem);
    opacity: 0.4;
    text-align: center;
    line-height: 1.8;
    max-width: 80%;
  }

  /* HUD */
  #hud {
    position: fixed;
    top: 0; left: 0;
    width: 100%;
    z-index: 20;
    padding: 0.8rem 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: clamp(0.7rem, 2.5vw, 0.9rem);
    background: linear-gradient(180deg, #000a 0%, transparent 100%);
    pointer-events: none;
  }
  #hud.hidden { display: none; }
  .hud-score { text-shadow: var(--glow-sm); font-family: 'Orbitron', sans-serif; font-weight: 700; }
  .hud-combo { color: var(--matrix-bright); font-size: 0.75em; }
  .hud-lives { display: flex; gap: 4px; }
  .life-pip {
    width: 12px; height: 12px;
    border: 1px solid var(--matrix-green);
    background: var(--matrix-green);
    box-shadow: var(--glow-sm);
    transition: all 0.3s;
  }
  .life-pip.lost { background: transparent; box-shadow: none; opacity: 0.3; }

  /* GAME CANVAS */
  #gameCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 5;
  }
  #gameCanvas.hidden { display: none; }

  /* GAME OVER */
  #gameOver h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(1.5rem, 6vw, 3rem);
    font-weight: 900;
    text-shadow: var(--glow);
    color: #ff3333;
  }
  #gameOver .final-score {
    font-size: clamp(2rem, 8vw, 4rem);
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    margin: 1.5rem 0;
    text-shadow: var(--glow);
  }
  #gameOver .stats {
    font-size: 0.8rem;
    opacity: 0.5;
    margin-bottom: 2rem;
    text-align: center;
    line-height: 2;
  }

  /* FLASH EFFECTS */
  #flashOverlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 15;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.05s;
  }
  #flashOverlay.hit {
    background: radial-gradient(circle, #ff000040, #ff000010);
    opacity: 1;
    animation: flashHit 0.3s forwards;
  }
  #flashOverlay.collect {
    background: radial-gradient(circle, #00ff4130, transparent);
    opacity: 1;
    animation: flashCollect 0.2s forwards;
  }
  @keyframes flashHit {
    0% { opacity: 1; }
    100% { opacity: 0; }
  }
  @keyframes flashCollect {
    0% { opacity: 1; }
    100% { opacity: 0; }
  }

  /* SCANLINE OVERLAY */
  #scanlines {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 25;
    pointer-events: none;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      #00000015 2px,
      #00000015 4px
    );
  }

  /* SLOW-MO INDICATOR */
  #slowMoBar {
    position: fixed;
    bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    width: 40%;
    height: 4px;
    background: #00ff4120;
    border-radius: 2px;
    z-index: 20;
    overflow: hidden;
  }
  #slowMoBar.hidden { display: none; }
  #slowMoFill {
    height: 100%;
    background: var(--matrix-green);
    box-shadow: var(--glow-sm);
    transition: width 0.1s;
    border-radius: 2px;
  }
  .slowmo-label {
    position: fixed;
    bottom: 1.8rem;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.55rem;
    letter-spacing: 0.3em;
    opacity: 0.4;
    z-index: 20;
    text-transform: uppercase;
  }
  .slowmo-label.hidden { display: none; }
</style>
</head>
<body>

<canvas id="rain"></canvas>
<div id="scanlines"></div>
<div id="flashOverlay"></div>

<!-- TITLE SCREEN -->
<div id="titleScreen" class="screen">
  <h1>SHATTARD</h1>
  <div class="subtitle">awaken</div>
  <button class="start-btn" onclick="startGame()">IN</button>
  <div class="instructions">
    SWIPE or DRAG to move<br>
    COLLECT green glyphs // DODGE red threats<br>
    DOUBLE TAP for bullet time
  </div>
</div>

<!-- HUD -->
<div id="hud" class="hidden">
  <div>
    <div class="hud-score">SCORE: <span id="scoreDisplay">0</span></div>
    <div class="hud-combo" id="comboDisplay"></div>
  </div>
  <div>
    <div class="hud-lives" id="livesDisplay"></div>
  </div>
</div>

<!-- SLOW-MO BAR -->
<div id="slowMoBar" class="hidden"><div id="slowMoFill" style="width:100%"></div></div>
<div class="slowmo-label hidden" id="slowMoLabel">BULLET TIME</div>

<!-- GAME CANVAS -->
<canvas id="gameCanvas" class="hidden"></canvas>

<!-- GAME OVER -->
<div id="gameOver" class="screen hidden">
  <h2>SYSTEM FAILURE</h2>
  <div class="final-score" id="finalScore">0</div>
  <div class="stats" id="finalStats"></div>
  <button class="start-btn" onclick="startGame()">REBOOT</button>
</div>

<script>
// ─── MATRIX RAIN BACKGROUND ───
const rainCanvas = document.getElementById('rain');
const rCtx = rainCanvas.getContext('2d');
let rainCols, drops;

function initRain() {
  rainCanvas.width = window.innerWidth;
  rainCanvas.height = window.innerHeight;
  const fontSize = 14;
  rainCols = Math.floor(rainCanvas.width / fontSize);
  drops = Array.from({ length: rainCols }, () => Math.random() * rainCanvas.height / fontSize);
}

function drawRain() {
  rCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
  rCtx.fillRect(0, 0, rainCanvas.width, rainCanvas.height);
  rCtx.fillStyle = '#00ff41';
  rCtx.font = '14px Share Tech Mono';
  const chars = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン0123456789';
  for (let i = 0; i < drops.length; i++) {
    const ch = chars[Math.floor(Math.random() * chars.length)];
    rCtx.fillText(ch, i * 14, drops[i] * 14);
    if (drops[i] * 14 > rainCanvas.height && Math.random() > 0.975) drops[i] = 0;
    drops[i]++;
  }
  requestAnimationFrame(drawRain);
}

initRain();
drawRain();
window.addEventListener('resize', initRain);

// ─── GAME STATE ───
const gc = document.getElementById('gameCanvas');
const ctx = gc.getContext('2d');
let W, H;
let player, entities, particles, score, combo, maxCombo, lives, gameRunning;
let slowMo, slowMoEnergy, slowMoCooldown;
let difficulty, spawnTimer, lastTime, elapsed;
let totalCollected, totalDodged;
let lastTap = 0;
let touchStartX, touchStartY, touching = false;

const PLAYER_SIZE = 22;
const MAX_LIVES = 3;
const TOUCH_Y_OFFSET = -80; // player renders above finger on touch devices
const SLOW_MO_DURATION = 3000;
const CHARS = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';

function resizeGame() {
  W = gc.width = window.innerWidth;
  H = gc.height = window.innerHeight;
}

// ─── ENTITY TYPES ───
function spawnGlyph() {
  const isGood = Math.random() < 0.45;
  const size = isGood ? 18 : (14 + Math.random() * 10);
  const speed = (1.5 + difficulty * 0.4 + Math.random() * 1.5) * (isGood ? 0.8 : 1);
  entities.push({
    type: isGood ? 'good' : 'bad',
    x: Math.random() * (W - 40) + 20,
    y: -30,
    size,
    speed,
    char: CHARS[Math.floor(Math.random() * CHARS.length)],
    alpha: 0.7 + Math.random() * 0.3,
    wobble: Math.random() * Math.PI * 2,
    wobbleSpeed: 0.5 + Math.random() * 2,
    wobbleAmp: isGood ? 0 : (10 + Math.random() * 20),
    trail: [],
  });
}

function spawnPowerUp() {
  entities.push({
    type: 'power',
    x: Math.random() * (W - 60) + 30,
    y: -30,
    size: 20,
    speed: 1 + Math.random(),
    char: '⬡',
    alpha: 1,
    wobble: 0, wobbleSpeed: 3, wobbleAmp: 15,
    pulsePhase: 0,
    trail: [],
  });
}

// ─── PARTICLES ───
function emitParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 4;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 0.5 + Math.random() * 0.5,
      maxLife: 0.5 + Math.random() * 0.5,
      color,
      size: 1 + Math.random() * 3,
      char: Math.random() > 0.5 ? CHARS[Math.floor(Math.random() * CHARS.length)] : null,
    });
  }
}

// ─── PLAYER ───
function initPlayer() {
  player = {
    x: W / 2,
    y: H * 0.8,
    targetX: W / 2,
    targetY: H * 0.8,
    size: PLAYER_SIZE,
    glowPhase: 0,
  };
}

// ─── INPUT ───
gc.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
  touching = true;
  player.targetX = t.clientX;
  player.targetY = t.clientY + TOUCH_Y_OFFSET;

  // Double tap detection
  const now = Date.now();
  if (now - lastTap < 300) activateSlowMo();
  lastTap = now;
}, { passive: false });

gc.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (!touching) return;
  const t = e.touches[0];
  player.targetX = t.clientX;
  player.targetY = t.clientY + TOUCH_Y_OFFSET;
}, { passive: false });

gc.addEventListener('touchend', () => { touching = false; });

// Mouse fallback
gc.addEventListener('mousedown', (e) => {
  touching = true;
  player.targetX = e.clientX;
  player.targetY = e.clientY;
  const now = Date.now();
  if (now - lastTap < 300) activateSlowMo();
  lastTap = now;
});
gc.addEventListener('mousemove', (e) => {
  if (!touching) return;
  player.targetX = e.clientX;
  player.targetY = e.clientY;
});
gc.addEventListener('mouseup', () => { touching = false; });

// ─── SLOW MOTION ───
function activateSlowMo() {
  if (slowMoEnergy < 30 || slowMoCooldown > 0) return;
  slowMo = true;
  setTimeout(() => { slowMo = false; }, SLOW_MO_DURATION);
}

// ─── FLASH ───
function flash(type) {
  const el = document.getElementById('flashOverlay');
  el.className = '';
  void el.offsetWidth;
  el.classList.add(type);
}

// ─── VIBRATE ───
function vibrate(ms) {
  if (navigator.vibrate) navigator.vibrate(ms);
}

// ─── UPDATE LIVES DISPLAY ───
function updateLivesUI() {
  const el = document.getElementById('livesDisplay');
  el.innerHTML = '';
  for (let i = 0; i < MAX_LIVES; i++) {
    const pip = document.createElement('div');
    pip.className = 'life-pip' + (i >= lives ? ' lost' : '');
    el.appendChild(pip);
  }
}

// ─── COLLISION ───
function dist(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

// ─── START GAME ───
function startGame() {
  document.getElementById('titleScreen').classList.add('hidden');
  document.getElementById('gameOver').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  document.getElementById('slowMoBar').classList.remove('hidden');
  document.getElementById('slowMoLabel').classList.remove('hidden');
  gc.classList.remove('hidden');

  resizeGame();
  window.addEventListener('resize', resizeGame);

  entities = [];
  particles = [];
  score = 0;
  combo = 0;
  maxCombo = 0;
  lives = MAX_LIVES;
  difficulty = 0;
  spawnTimer = 0;
  slowMo = false;
  slowMoEnergy = 100;
  slowMoCooldown = 0;
  totalCollected = 0;
  totalDodged = 0;
  gameRunning = true;
  lastTime = performance.now();

  initPlayer();
  updateLivesUI();
  requestAnimationFrame(gameLoop);
}

// ─── GAME LOOP ───
function gameLoop(now) {
  if (!gameRunning) return;

  const rawDt = (now - lastTime) / 1000;
  lastTime = now;
  const dt = Math.min(rawDt, 0.05);
  const timeScale = slowMo ? 0.3 : 1;
  elapsed = dt * timeScale;

  update(elapsed, dt);
  render();
  requestAnimationFrame(gameLoop);
}

function update(dt, realDt) {
  // Difficulty ramp
  difficulty = Math.min(score / 500, 8);

  // Slow-mo energy
  if (slowMo) {
    slowMoEnergy = Math.max(0, slowMoEnergy - realDt * 35);
    if (slowMoEnergy <= 0) slowMo = false;
  } else {
    slowMoEnergy = Math.min(100, slowMoEnergy + realDt * 8);
  }
  if (slowMoCooldown > 0) slowMoCooldown -= realDt;
  document.getElementById('slowMoFill').style.width = slowMoEnergy + '%';

  // Player movement (smooth follow)
  const ease = 0.15;
  player.x += (player.targetX - player.x) * ease;
  player.y += (player.targetY - player.y) * ease;
  player.x = Math.max(player.size, Math.min(W - player.size, player.x));
  player.y = Math.max(player.size, Math.min(H - player.size, player.y));
  player.glowPhase += dt * 4;

  // Spawning
  const spawnRate = Math.max(0.15, 0.6 - difficulty * 0.05);
  spawnTimer += dt;
  if (spawnTimer >= spawnRate) {
    spawnTimer = 0;
    spawnGlyph();
    if (Math.random() < 0.04) spawnPowerUp();
  }

  // Update entities
  for (let i = entities.length - 1; i >= 0; i--) {
    const e = entities[i];
    e.wobble += e.wobbleSpeed * dt;
    e.y += e.speed * 60 * dt;
    e.x += Math.sin(e.wobble) * e.wobbleAmp * dt;

    if (e.type === 'power') e.pulsePhase = (e.pulsePhase || 0) + dt * 5;

    // Trail
    e.trail.push({ x: e.x, y: e.y, alpha: 0.5 });
    if (e.trail.length > 6) e.trail.shift();
    e.trail.forEach(t => t.alpha *= 0.9);

    // Off screen
    if (e.y > H + 50) {
      if (e.type === 'bad') totalDodged++;
      entities.splice(i, 1);
      continue;
    }

    // Collision with player
    const d = dist(e, player);
    const hitDist = player.size + e.size * 0.6;
    if (d < hitDist) {
      if (e.type === 'good') {
        score += 10 * (1 + combo * 0.5);
        combo++;
        maxCombo = Math.max(maxCombo, combo);
        totalCollected++;
        emitParticles(e.x, e.y, '#00ff41', 8);
        flash('collect');
      } else if (e.type === 'power') {
        slowMoEnergy = 100;
        score += 50;
        emitParticles(e.x, e.y, '#00ffff', 15);
        flash('collect');
      } else {
        lives--;
        combo = 0;
        updateLivesUI();
        emitParticles(e.x, e.y, '#ff3333', 20);
        flash('hit');
        vibrate(100);
        if (lives <= 0) {
          gameOver();
          return;
        }
      }
      entities.splice(i, 1);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * 60 * dt;
    p.y += p.vy * 60 * dt;
    p.vy += 2 * dt;
    p.life -= dt;
    if (p.life <= 0) { particles.splice(i, 1); }
  }

  // Update HUD
  document.getElementById('scoreDisplay').textContent = Math.floor(score);
  document.getElementById('comboDisplay').textContent = combo > 1 ? `x${combo} COMBO` : '';
}

// ─── RENDER ───
function render() {
  ctx.clearRect(0, 0, W, H);

  // Vignette
  const vg = ctx.createRadialGradient(W/2, H/2, H*0.2, W/2, H/2, H*0.8);
  vg.addColorStop(0, 'transparent');
  vg.addColorStop(1, 'rgba(0,0,0,0.6)');
  ctx.fillStyle = vg;
  ctx.fillRect(0, 0, W, H);

  // Slow-mo tint
  if (slowMo) {
    ctx.fillStyle = 'rgba(0, 255, 65, 0.03)';
    ctx.fillRect(0, 0, W, H);
  }

  // Entities
  for (const e of entities) {
    // Trail
    for (const t of e.trail) {
      ctx.globalAlpha = t.alpha * 0.15;
      ctx.fillStyle = e.type === 'bad' ? '#ff3333' : e.type === 'power' ? '#00ffff' : '#00ff41';
      ctx.font = `${e.size}px Share Tech Mono`;
      ctx.textAlign = 'center';
      ctx.fillText(e.char, t.x, t.y);
    }

    ctx.globalAlpha = e.alpha;
    if (e.type === 'bad') {
      ctx.fillStyle = '#ff3333';
      ctx.shadowColor = '#ff3333';
      ctx.shadowBlur = 8;
    } else if (e.type === 'power') {
      const pulse = 0.7 + Math.sin(e.pulsePhase) * 0.3;
      ctx.fillStyle = `rgba(0, 255, 255, ${pulse})`;
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 15;
    } else {
      ctx.fillStyle = '#00ff41';
      ctx.shadowColor = '#00ff41';
      ctx.shadowBlur = 6;
    }
    ctx.font = `bold ${e.size}px Share Tech Mono`;
    ctx.textAlign = 'center';
    ctx.fillText(e.char, e.x, e.y);
    ctx.shadowBlur = 0;
  }

  // Particles
  for (const p of particles) {
    const a = p.life / p.maxLife;
    ctx.globalAlpha = a;
    ctx.fillStyle = p.color;
    if (p.char) {
      ctx.font = `${p.size * 4}px Share Tech Mono`;
      ctx.textAlign = 'center';
      ctx.fillText(p.char, p.x, p.y);
    } else {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * a, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Player
  ctx.globalAlpha = 1;
  const glow = 8 + Math.sin(player.glowPhase) * 4;
  
  // Player outer ring
  ctx.strokeStyle = '#00ff41';
  ctx.shadowColor = '#00ff41';
  ctx.shadowBlur = glow;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
  ctx.stroke();

  // Player inner hexagon
  ctx.fillStyle = '#00ff4130';
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = (Math.PI / 3) * i - Math.PI / 6 + player.glowPhase * 0.3;
    const r = player.size * 0.7;
    const px = player.x + Math.cos(angle) * r;
    const py = player.y + Math.sin(angle) * r;
    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#00ff4180';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Center dot
  ctx.fillStyle = '#00ff41';
  ctx.shadowBlur = 12;
  ctx.beginPath();
  ctx.arc(player.x, player.y, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  ctx.globalAlpha = 1;
}

// ─── GAME OVER ───
function gameOver() {
  gameRunning = false;
  document.getElementById('hud').classList.add('hidden');
  document.getElementById('slowMoBar').classList.add('hidden');
  document.getElementById('slowMoLabel').classList.add('hidden');
  gc.classList.add('hidden');

  document.getElementById('finalScore').textContent = Math.floor(score);
  document.getElementById('finalStats').innerHTML =
    `GLYPHS COLLECTED: ${totalCollected}<br>` +
    `THREATS DODGED: ${totalDodged}<br>` +
    `MAX COMBO: x${maxCombo}`;

  setTimeout(() => {
    document.getElementById('gameOver').classList.remove('hidden');
  }, 300);
}
</script>
</body>
</html>